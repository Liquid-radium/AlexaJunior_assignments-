module mac(input clk, input reset, input [7:0]a, input [7:0]b, output reg [15:0] acc_reg);

wire [15:0] product;
assign product = a*b;


always @ (posedge clk or posedge reset)
begin
if(reset)
begin
acc_reg <= 0;
end
else
begin
acc_reg <= product + acc_reg;
end
end
endmodule

`timescale 1ns/1ps
module mac_tb;
reg clk,reset;
reg [7:0] a, b;
wire [15:0] acc_reg;
mac uut(.clk(clk), .reset(reset), .a(a), .b(b), .acc_reg(acc_reg));
initial clk =0;
always #5 clk = ~clk;
initial begin
reset = 1;a=0; b=0;
$monitor("time = %t | reset = %b | a = %d | b = %d | acc = %d", $time,reset,a,b,acc_reg);
#10; reset = 0; a=8; b=7;
#10; a=10; b=2;
#10; a=0; b=9;
#10; a=6; b=3;
#10; reset = 1; 
#10;reset=0; a=9; b=5;
#20;
$finish;

end
endmodule



module pipelined_mac (
    input clk,
    input reset,
    input [7:0] A, B,
    output reg [15:0] ACC
);

    // Stage 1: Input registers
    reg [7:0] A_reg, B_reg;

    // Stage 2: Product register
    reg [15:0] product_reg;

    // Stage 3: Accumulator
    reg [15:0] acc_reg;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            A_reg <= 0;
            B_reg <= 0;
            product_reg <= 0;
            acc_reg <= 0;
            ACC <= 0;
        end
        else begin
            // Stage 1: Latch inputs
            A_reg <= A;
            B_reg <= B;

            // Stage 2: Multiply previous inputs
            product_reg <= A_reg * B_reg;

            // Stage 3: Accumulate
            acc_reg <= acc_reg + product_reg;

            // Output result
            ACC <= acc_reg;
        end
    end

endmodule

`timescale 1ns / 1ps
module pipelined_mac_tb;

    reg clk, reset;
    reg [7:0] A, B;
    wire [15:0] ACC;

    pipelined_mac uut (.clk(clk), .reset(reset), .A(A), .B(B), .ACC(ACC));

    always #5 clk = ~clk;

    initial begin
        clk = 0; reset = 0; A = 0; B = 0;
        $monitor("Time=%0t | A=%d | B=%d | ACC=%d", $time, A, B, ACC);

        reset = 1; #10; reset = 0; #10;

        A = 4; B = 5; #10;
        A = 3; B = 6; #10;
        A = 2; B = 7; #10;
        A = 8; B = 8; #10;

        #30;
        $finish;
    end
endmodule

module mac_overflow (
    input clk,
    input reset,
    input [7:0] A, B,
    output reg [15:0] ACC,
    output reg overflow
);

    wire [15:0] product;
    wire [16:0] sum;  

    assign product = A * B;
    assign sum = ACC + product;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ACC <= 0;
            overflow_flag <= 0;
        end
        else begin
            ACC <= sum[15:0];
            overflow <= sum[16];  
        end
    end
endmodule




